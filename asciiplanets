#!/usr/bin/env python


from datetime import datetime, timedelta
from math import cos, sin, sqrt

import argparse
import ephem
import fcntl
import os
import struct
import sys
import termios


class Canvas(object):
    def __init__(self, width, height, font_aspect,
                 inner=False, outer=False, span=2.0):
        self.width = width
        self.height = height
        self.data = [' ' for i in range(width * height)]

        if inner:
            self.span = 1.75
        elif outer:
            self.span = 31.9
        else:
            self.span = span

        # If, for example, your font is 16 pixels high and 8 pixels
        # wide, then font_aspect = 8 / 16 = 0.5. For each character in y
        # direction, you then need 2 characters in x direction to create
        # a square.
        self.apparent_width = self.width * font_aspect

        if self.apparent_width > self.height:
            self.span_x = self.span / self.height * self.apparent_width
            self.span_y = self.span
        else:
            self.span_x = self.span
            self.span_y = self.span / self.apparent_width * self.height

    def mark_date(self, offset):
        s = (datetime.utcnow() + offset).strftime('%F')
        a = self.width - len(s)
        for i in s:
            if a >= 0 and a < self.width:
                self.data[a] = i
            a += 1

    def mark_setup(self):
        s = 'Radius: {:.2f} AU'.format(self.span)
        a = 0
        for i in s:
            if a >= 0 and a < self.width:
                self.data[a] = i
            a += 1

    def set_position(self, c, x, y):
        sx = 0.5 * (x / self.span_x + 1) * self.width
        sy = 0.5 * (-y / self.span_y + 1) * self.height
        if sx < 0 or sx >= self.width or sy < 0 or sy >= self.height:
            return
        self.data[int(sy) * self.width + int(sx)] = c

    def show(self, no_trailing_newline):
        for y in range(self.height):
            for x in range(self.width):
                sys.stdout.write(self.data[y * self.width + x])
            if not no_trailing_newline or y + 1 < self.height - 1:
                sys.stdout.write('\n')

def pos(body, offset):
    body.compute(datetime.utcnow() + offset)
    r = body.sun_distance if body.name != 'Sun' else body.earth_distance
    l = body.hlon
    b = body.hlat

    x = r * cos(b) * cos(l)
    y = r * cos(b) * sin(l)
    return (x, y, l, b)

def orbit(body, canvas):
    # Very rough approximation of sidereal orbit using Kepler's third
    # law. We do this only to get a good estimate on the required step
    # size.
    body.compute()
    r = body.sun_distance if body.name != 'Sun' else body.earth_distance
    r *= 149597870700
    approx_T = sqrt(4 * ephem.pi**2 / (6.67384e-11 * 1.9884e30) * r**3)
    approx_T_days = approx_T / (60 * 60 * 24)

    # We'd like to draw 128 steps but we don't know the step size to do
    # so. Thus, we just keep drawing until we covered 360 degree. This
    # might result in more than 128 steps (or less).
    steps = 128
    last_l = None
    asum = 0
    i = 0
    while True:
        x, y, l, _ = pos(body, timedelta(days=i / steps * approx_T_days))
        if not last_l is None:
            delta = l - last_l
            if delta < 0:
                delta += 2 * ephem.pi
            asum += delta
        if asum >= 2 * ephem.pi:
            break
        last_l = l
        canvas.set_position('.', x, y)
        i += 1

def termsize():
    fd = sys.stdout.fileno()
    if os.isatty(fd):
        height, width = struct.unpack('hh', fcntl.ioctl(fd, termios.TIOCGWINSZ, 'aaaa'))
        return width, height
    else:
        return 80, 24


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Show planets in our solar system',
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--outer', action='store_true', help='Show outer solar system')
    parser.add_argument('--radius', type=float, help='Maximum radius to show')
    parser.add_argument('--offset', type=int, default=0, help='Time offset in days')
    parser.add_argument('--size', type=str, default='auto', help='Terminal size, e.g. "80x24"')
    parser.add_argument('--font-aspect', type=float, default=0.5,
                        help='Aspect ratio of your terminal\'s font (x / y)')
    parser.add_argument('--no-colors', action='store_true', help='Disable colors')
    parser.add_argument('--no-trailing-newline', '-T', action='store_true',
                        help='Do not print a newline after the last row')
    args = parser.parse_args()

    offset = timedelta(days=args.offset)

    if args.size == 'auto':
        width, height = termsize()
    else:
        width, height = [int(i) for i in args.size.split('x')]

    if args.radius:
        canvas = Canvas(width, height, args.font_aspect, span=args.radius)
    else:
        canvas = Canvas(width, height, args.font_aspect, inner=not args.outer, outer=args.outer)
    canvas.mark_date(offset)
    canvas.mark_setup()

    if args.no_colors:
        chars = {
            'Mercury': 'm',
            'Venus': 'V',
            'Sun': 'E',      # pyephem class "Sun" is used to calc Earth
            'Mars': 'M',
            'Jupiter': 'J',
            'Saturn': 'S',
            'Uranus': 'U',
            'Neptune': 'N',
            '_SUN': 'S',
        }
    else:
        chars = {
            'Mercury': 'm',
            'Venus': '\033[33mV\033[0m',
            'Sun': '\033[34mE\033[0m',
            'Mars': '\033[31mM\033[0m',
            'Jupiter': '\033[31;1mJ\033[0m',
            'Saturn': '\033[33ms\033[0m',
            'Uranus': '\033[34;1mU\033[0m',
            'Neptune': '\033[36mN\033[0m',
            '_SUN': '\033[33;1mS\033[0m',
        }

    bodies = [ephem.Mercury(), ephem.Venus(), ephem.Sun(), ephem.Mars(),
              ephem.Jupiter(), ephem.Saturn(), ephem.Uranus(), ephem.Neptune()]

    for b in bodies:
        orbit(b, canvas)

    for b in bodies:
        x, y, _, _ = pos(b, offset)
        canvas.set_position(chars[b.name], x, y)

    canvas.set_position(chars['_SUN'], 0, 0)

    canvas.show(args.no_trailing_newline)
